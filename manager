#!/bin/bash

# ~~~~~ CONFIGURATIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~

# Moved to manager.conf
source "$(dirname "$0")/manager.conf"

# ~~~~~ DO NOT EDIT BELOW THIS LINE ~~~~~~~~~~~~~

function divider() {
	echo -e "\e[90m$(yes "\e[90mâ”€\e[0m" | sed ''''$(stty size | awk '{print $2}')'''q' | tr -d '\n')\e[0m"
}

function red() {
	echo -e "\e[31m!\e[0;1m $@\e[0m"
}
function yellow() {
	echo -e "\e[33m?\e[0;1m $@\e[0m"
}
function green() {
	echo -e "\e[32m*\e[0;1m $@\e[0m"
}
function choose() {
	echo -e -n "$@ \e[1m[\e[32mY\e[0;1m/\e[31mn\e[0;1m]\e[0m "
	read user_choice
	if [[ $(echo $user_choice | grep -i "n") ]]; then
		export return=1
	else
		export return=0
	fi
}
function try() {
	echo -e -n "\e[90m"
	eval "$@"
	case $? in
	"0")
		green "$@"
		;;
	*)
		echo -e -n "\e[0m"
		yellow "$@"
		choose "Do you want to run this command with sudo? (You may need to fix some issues before that)"
		case $return in
		"0")
			echo -e -n "\e[90m"
			sudo "$@"
			case $? in
			"0")
				green "$@"
				;;
			*)
				red "$@"
				exit 1
				;;
			esac
			;;
		"1")
			red "Closed"
			exit 1
			;;
		esac
		;;
	esac
}

function Checking() {
	{ [[ -d $1 ]] || [[ -f $1 ]]; } || { try mkdir -p "$1" && try chmod 777 -R "$1"; }
}

if [[ ! $DIR ]]; then
	red "You need to set a directory"
	exit 1
fi

if [[ ! $BRANCH ]]; then
	red "You need to set a branch name"
	exot 1
fi

if [[ $1 ]]; then
	if [[ $(command -v lsb_release) ]]; then
		if [[ $(lsb_release -i | grep -i "arch") ]]; then
			green "Arch Linux detected"
		else
			red "This script is only allowed to run on Arch Linux."
			exit 1
		fi
	else
		if [[ $(cat /etc/os-release | grep -i "arch") ]]; then
			green "Arch Linux detected"
		else
			red "This script is only allowed to run on Arch Linux."
			exit 1
		fi
	fi
	try Checking "$DIR"/home
	try Checking "$DIR"/config
	try Checking "$DIR"/etc
	try Checking "$DIR"/env
fi

# ~~~~~ MAIN FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~

function update() {
	if [[ $HOME ]]; then
		for dotfile in "${DOTFILES[@]}"; do
			export position="$HOME/$dotfile"
			try cp -rpuv "$position" "$DIR"/home
		done
	fi

	if [[ $CONFIG ]]; then
		for config in "${CONFIG[@]}"; do
			export position="$HOME/.config/$config"
			try cp -rpuv "$position" "$DIR"/config
		done
	fi

	if [[ $ETC ]]; then
		for etc in "${ETC[@]}"; do
			export position="/etc/$etc"
			try cp -rpuv "$position" "$DIR"/etc
		done
	fi

	if [[ $(command -v pacman) ]]; then
		try "pacman -Qq > "$DIR"/env/pacman.list"
	fi
}

function init() {
	if [[ ! -d "$DIR/.git" ]]; then
		yellow "You need to initialize a Git repository first."
		try git init
		try git branch -M main
		yellow "Adding remote repository"
		read -p "Your username is " username
		read -p "Your token/passwd is " token
		read -p "Your repo url is https://" link
		export link="https://$username:$token@$link"
		try git remote add origin "$link"
	fi
}

function push() {
	[[ -d "$DIR"/.git ]] || init
	try git add .
	yellow "You need to input a commit message"
	read -p "Your commit message is " MSG
	try git commit -am \""$MSG"\"
	try git branch -M "$BRANCH"
	try git push -uf origin "$BRANCH"
}

function select_commit() {
    # è·å–æ ¼å¼åŒ–çš„æäº¤æ—¥å¿—å¹¶å€’åºæ’åˆ—ï¼ˆä¸æ˜¾ç¤ºå“ˆå¸Œï¼‰
    local commits
    commits=$(git log --reverse --pretty=format:"%s")
	date=$(git log --reverse --pretty=format:"%ad" --date=format:"%y.%m.%d")

    # æ˜¾ç¤ºæäº¤æ—¥å¿—å¹¶è®©ç”¨æˆ·é€‰æ‹©
    yellow "We will revert to"
    IFS=$'\n' read -r -d '' -a commit_array <<<"$commits"
	DATE=$'\n' read -r -d '' -a date_array <<<"$date"
    for i in "${!commit_array[@]}"; do
        echo -e "  \e[1;35m$i\e[0;1m ${commit_array[$i]}\e[0m \e[2;90m${date_array[$i]}\e[0m"
    done

    # è¯»å–ç”¨æˆ·é€‰æ‹©
    read -p "Your choice is number " choice
    if [[ ! $choice =~ ^[0-9]+$ ]] || ((choice < 0 || choice >= ${#commit_array[@]})); then
        red "Not a valid choice, please enter a number between 0 and $((${#commit_array[@]} - 1))."
        exit 1
    fi

    # è·å–å¯¹åº”çš„æäº¤å“ˆå¸Œ
    local selected_commit="${commit_array[$choice]}"
    local hash
    hash=$(git log --reverse --pretty=format:"%H %s %ad" --date=format:"%y.%m.%d" | grep -F -m 1 "${selected_commit}" | awk '{print $1}')

    # æ£€æŸ¥æ˜¯å¦æˆåŠŸæå–åˆ°å“ˆå¸Œå€¼
    if [[ -z "$hash" ]]; then
        red "We couldn't find the commit hash for your choice."
        exit 1
    fi

    # æ˜¾ç¤ºçŸ­å“ˆå¸Œå€¼å¹¶ç¡®è®¤æ˜¯å¦æ¢å¤
    local short_hash="${hash:0:7}"
    yellow "Revert"
    choose "Should we revert to commit $short_hash?"
    case $return in
    "0")
        try git reset --hard "$hash"
        ;;
    "1")
        red "Closed"
        exit 1
        ;;
    esac
}

function copy() {
	yellow "Copy your dotfiles"
	choose "Should we copy your dotfiles to $HOME?"
	case $return in
	"0")
		for dotfile in "${DOTFILES[@]}"; do
			export position="$DIR/home/$dotfile"
			try cp -rpuv "$position" "$HOME"
		done
		;;
	"1")
		red "Closed"
		;;
	esac

	yellow "Copy your config files"
	choose "Should we copy your config files to $HOME/.config?"
	case $return in
	"0")
		for config in "${CONFIG[@]}"; do
			export position="$DIR/config/$config"
			try cp -rpuv "$position" "$HOME/.config"
		done
		;;
	"1")
		red "Closed"
		;;
	esac
	yellow "Copy your etc configs"
	choose "Should we copy your etc configs to /etc?"
	case $return in
	"0")
		for etc in "${ETC[@]}"; do
			export position="$DIR/etc/$etc"
			try cp -rpuv "$position" "/etc/$etc"
		done
		;;
	"1")
		red "Closed"
		;;
	esac
	yellow "Install packages"
	choose "Should we install your packages?"
	case $return in
	"0")
		if [[ $(command -v yay) ]]; then
			try yay -S --needed - <"$DIR"/env/pacman.list
		elif [[ $(command -v paru) ]]; then
			try paru -S --needed - <"$DIR"/env/pacman.list
		else
			red "No AUR helper found, please install it manually"
		fi
		;;
	"1")
		red "Closed"
		;;
	esac
}

function pull() {
	try git pull
}

function generate_readme() {
    local readme_path="$DIR/README.md"

    # è·å– CPU ä¿¡æ¯
    local cpu_info
    cpu_info=$(grep -m 1 "model name" /proc/cpuinfo | awk -F': ' '{print $2}')
    if [[ -z "$cpu_info" ]]; then
        cpu_info="Unknown CPU"
    fi

    # è·å–å†…å­˜ä¿¡æ¯
    local memory_info
    memory_info=$(grep -m 1 "MemTotal" /proc/meminfo | awk '{printf "%.2f GB", $2 / 1024 / 1024}')
    if [[ -z "$memory_info" ]]; then
        memory_info="Unknown Memory"
    fi

    # å†™å…¥æ ‡é¢˜å’Œè¯´æ˜
    cat > "$readme_path" <<EOF
# âœ¨ Silvaire's Dotfiles

> [!NOTE]
> I use Silvaire's Dotfiles Manager btw

## ğŸ’» HOSTS

| ITEM   | VALUE                                |
| ------ | ------------------------------------ |
| Kernel | $(uname -r)                          |
| System | $(lsb_release -d | awk -F'\t' '{print $2}') |
| CPU    | $cpu_info                            |
| GPU    | $(lspci | grep -i vga | awk -F': ' '{print $2}') |
| Memory | $memory_info                         |



## ğŸ¤” Dotfiles Manager
How can I use this dotfiles manager?

> [!CAUTION]
> This script is only allowed to run on Arch Linux.

0. Install \`git\` and \`bash\`
1. Clone this repository.
2. Remove config, env, etc, and home folders.
3. Edit manager.conf.
4. Run \`manager -i\` to initialize the git repository.
5. Run \`manager -p\` to copy your dotfiles and push your changes.

## âš™ï¸ PACKAGES

| CONFIG        | ETC          | HOME        |
| ------------- | ------------ | ----------- |
EOF

    # å†™å…¥é…ç½®æ–‡ä»¶
    local max_length=$(( ${#CONFIG[@]} > ${#ETC[@]} ? ${#CONFIG[@]} : ${#ETC[@]} ))
    max_length=$(( max_length > ${#DOTFILES[@]} ? max_length : ${#DOTFILES[@]} ))

    for ((i = 0; i < max_length; i++)); do
        local config_item="${CONFIG[i]:-}"
        local etc_item="${ETC[i]:-}"
        local home_item="${DOTFILES[i]:-}"
        printf "| %-13s | %-12s | %-11s |\n" "$config_item" "$etc_item" "$home_item" >> "$readme_path"
    done

    green "README.md has been generated at $readme_path"
}

case $1 in
"-r")
	update
	;;
"-i")
	init
	;;
"-p")
	update
	init
	# Auto generate README.md
	generate_readme
	if [[ -z "$(git status --porcelain)" ]]; then
		red "No changes to commit"
		exit 1
	fi
	push
	;;
"-l")
	pull
	;;
"-b")
	init
	select_commit
	;;
"-c")
	copy
	;;
*)
	echo -e "
\e[0;1mSilvaire's Dotfiles Manager\e[0m
Released under the \e[0;1mGPL v3.0\e[0m license.
\e[31;1mThis script is only allowed to run on Arch Linux.\e[0m

\e[0;1mUsage: $0 [option]\e[0m

\e[0;1mOptions:\e[0m
  \e[0;1m-b\e[0m  Revert to one of the previous commits
  \e[0;1m-c\e[0m  Reproduce your dotfiles
  \e[0;1m-i\e[0m  Initialize the git repository (if not already initialized)
  \e[0;1m-l\e[0m  Pull the latest changes from the remote repository
  \e[0;1m-p\e[0m  Recopy and push your changes to the remote repository
  \e[0;1m-r\e[0m  Recopy your dotfiles

\e[0;1mTips:\e[0m
  You can run \e[1m$0 [option] | yes\e[0m
  to automatically answer all the questions with 'yes'.

\e[0;1mWARNING:\e[0m
  1. Please don't move this script to another directory,
     because there is a config file in the same directory.
  2. For security reasons, 
     when you delete a software's name from the config file, 
     we will not automatically delete that software's config file for you.
"
	exit 1
	;;
esac
